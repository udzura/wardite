# Generated from lib/wardite.rb with RBS::Inline

module Wardite
  class Section
    attr_accessor name: String

    attr_accessor code: Integer

    attr_accessor size: Integer
  end

  class TypeSection < Section
    attr_accessor defined_types: Array[Array[Symbol]]

    attr_accessor defined_results: Array[Array[Symbol]]

    # @rbs return: void
    def initialize: () -> void
  end

  class FunctionSection < Section
    attr_accessor func_indices: Array[Integer]

    # @rbs return: void
    def initialize: () -> void
  end

  class MemorySection < Section
    attr_accessor limits: Array[[ Integer, Integer | nil ]]

    # @rbs return: void
    def initialize: () -> void
  end

  class CodeSection < Section
    class CodeBody
      attr_accessor locals_count: Array[Integer]

      attr_accessor locals_type: Array[Symbol]

      attr_accessor body: Array[Op]

      # @rbs &blk: (CodeBody) -> void
      # @rbs return: void
      def initialize: () { (CodeBody) -> void } -> void
    end

    attr_accessor func_codes: Array[CodeBody]

    # @rbs return: void
    def initialize: () -> void
  end

  class DataSection < Section
    class Segment
      attr_accessor flags: Integer

      attr_accessor offset: Integer

      attr_accessor data: String

      # @rbs &blk: (Segment) -> void
      # @rbs return: void
      def initialize: () { (Segment) -> void } -> void
    end

    attr_accessor segments: Array[Segment]

    # @rbs return: void
    def initialize: () -> void
  end

  class ExportSection < Section
    class ExportDesc
      attr_accessor name: String

      attr_accessor kind: Integer

      attr_accessor func_index: Integer
    end

    attr_accessor exports: Hash[String, ExportDesc]

    def initialize: () -> void

    # @rbs &blk: (ExportDesc) -> void
    def add_desc: () { (ExportDesc) -> void } -> untyped
  end

  class ImportSection < Section
    class ImportDesc
      attr_accessor module_name: String

      attr_accessor name: String

      attr_accessor kind: Integer

      attr_accessor sig_index: Integer
    end

    attr_accessor imports: Array[ImportDesc]

    def initialize: () -> void

    # @rbs &blk: (ImportDesc) -> void
    def add_desc: () { (ImportDesc) -> void } -> untyped
  end

  module BinaryLoader
    extend Wardite::Leb128Helpers

    # @rbs buf: File|StringIO
    # @rbs import_object: Hash[Symbol, Hash[Symbol, Proc]]
    # @rbs enable_wasi: boolish
    # @rbs return: Instance
    def self.load_from_buffer: (File | StringIO buf, ?import_object: Hash[Symbol, Hash[Symbol, Proc]], ?enable_wasi: boolish) -> Instance

    # @rbs return: Integer
    def self.preamble: () -> Integer

    # @rbs return: Array[Section]
    def self.sections: () -> Array[Section]

    # @rbs return: TypeSection
    def self.type_section: () -> TypeSection

    # @rbs return: ImportSection
    def self.import_section: () -> ImportSection

    # @rbs return: MemorySection
    def self.memory_section: () -> MemorySection

    # @rbs return: FunctionSection
    def self.function_section: () -> FunctionSection

    # @rbs return: CodeSection
    def self.code_section: () -> CodeSection

    # @rbs buf: StringIO
    # @rbs return: Array[::Wardite::Op]
    def self.code_body: (StringIO buf) -> Array[::Wardite::Op]

    # @rbs return: DataSection
    def self.data_section: () -> DataSection

    # @rbs sbuf: StringIO
    # @rbs return: String
    def self.fetch_insn_while_end: (StringIO sbuf) -> String

    # @rbs ops: Array[Op]
    # @rbs return: Integer
    def self.decode_expr: (Array[Op] ops) -> Integer

    # @rbs return: ExportSection
    def self.export_section: () -> ExportSection

    # @rbs code: Integer
    # @rbs return: nil
    def self.unimplemented_skip_section: (Integer code) -> nil

    # @rbs sbuf: StringIO
    # @rbs n: Integer
    # @rbs return: String
    def self.assert_read: (StringIO sbuf, Integer n) -> String
  end

  class Instance
    attr_accessor version: Integer

    attr_accessor sections: Array[Section]

    attr_accessor runtime: Runtime

    attr_accessor store: Store

    attr_accessor exports: Exports

    attr_reader import_object: Hash[Symbol, Hash[Symbol, Proc]]

    # @rbs import_object: Hash[Symbol, Hash[Symbol, Proc]]
    # @rbs &blk: (Instance) -> void
    def initialize: (Hash[Symbol, Hash[Symbol, Proc]] import_object) { (Instance) -> void } -> untyped

    # @rbs return: ImportSection
    def import_section: () -> ImportSection

    # @rbs return: TypeSection|nil
    def type_section: () -> (TypeSection | nil)

    # @rbs return: MemorySection|nil
    def memory_section: () -> (MemorySection | nil)

    # @rbs return: DataSection|nil
    def data_section: () -> (DataSection | nil)

    # @rbs return: FunctionSection|nil
    def function_section: () -> (FunctionSection | nil)

    # @rbs return: CodeSection|nil
    def code_section: () -> (CodeSection | nil)

    # @rbs return: ExportSection
    def export_section: () -> ExportSection
  end

  class Runtime
    attr_accessor stack: Array[Object]

    attr_accessor call_stack: Array[Frame]

    attr_reader instance: Instance

    # @rbs inst: Instance
    def initialize: (Instance inst) -> untyped

    # @rbs name: String|Symbol
    # @rbs return: bool
    def callable?: (String | Symbol name) -> bool

    # @rbs name: String|Symbol
    # @rbs args: Array[Object]
    # @rbs return: Object|nil
    def call: (String | Symbol name, Array[Object] args) -> (Object | nil)

    # @rbs idx: Integer
    # @rbs args: Array[Object]
    # @rbs return: Object|nil
    def call_index: (Integer idx, Array[Object] args) -> (Object | nil)

    # @rbs wasm_function: WasmFunction
    # @rbs return: void
    def push_frame: (WasmFunction wasm_function) -> void

    # @rbs wasm_function: WasmFunction
    # @rbs return: Object|nil
    def invoke_internal: (WasmFunction wasm_function) -> (Object | nil)

    # @rbs external_function: ExternalFunction
    # @rbs return: Object|nil
    def invoke_external: (ExternalFunction external_function) -> (Object | nil)

    # @rbs return: void
    def execute!: () -> void

    # @rbs frame: Frame
    # @rbs insn: Op
    # @rbs return: void
    def eval_insn: (Frame frame, Op insn) -> void

    # @rbs ops: Array[Op]
    # @rbs pc_start: Integer
    # @rbs return: Integer
    def fetch_ops_while_end: (Array[Op] ops, Integer pc_start) -> Integer

    # unwind the stack and put return value if exists
    # @rbs sp: Integer
    # @rbs arity: Integer
    # @rbs return: void
    def stack_unwind: (Integer sp, Integer arity) -> void

    # @rbs finish: Integer
    # @rbs return: Array[Object]
    def drained_stack: (Integer finish) -> Array[Object]

    # @rbs name: Symbol
    # @rbs args: Array[Object]
    # @rbs return: untyped
    def method_missing: (Symbol name, *untyped args) -> untyped

    # @rbs name: String|Symbol
    # @rbs return: bool
    def respond_to?: (String | Symbol name) -> bool
  end

  class Frame
    attr_accessor pc: Integer

    attr_accessor sp: Integer

    attr_accessor body: Array[Op]

    attr_accessor arity: Integer

    attr_accessor labels: Array[Label]

    attr_accessor locals: Array[Object]

    # @rbs pc: Integer
    # @rbs sp: Integer
    # @rbs body: Array[Op]
    # @rbs arity: Integer
    # @rbs locals: Array[Object]
    # @rbs returb: void
    def initialize: (Integer pc, Integer sp, Array[Op] body, Integer arity, Array[Object] locals) -> untyped
  end

  class Label
    attr_accessor kind: :if | :loop | :block

    attr_accessor pc: Integer

    attr_accessor sp: Integer

    attr_accessor arity: Integer

    # @rbs kind: (:if|:loop|:block)
    # @rbs pc: Integer
    # @rbs sp: Integer
    # @rbs arity: Integer
    # @rbs returb: void
    def initialize: (:if | :loop | :block kind, Integer pc, Integer sp, Integer arity) -> untyped
  end

  class Store
    attr_accessor funcs: Array[WasmFunction | ExternalFunction]

    attr_accessor memories: Array[Memory]

    # @rbs inst: Instance
    # @rbs return: void
    def initialize: (Instance inst) -> void

    # @rbs idx: Integer
    def []: (Integer idx) -> untyped
  end

  class Memory
    attr_accessor data: String

    attr_accessor max: Integer | nil

    # @rbs min: Integer
    # @rbs max: Integer|nil
    # @rbs return: void
    def initialize: (Integer min, Integer | nil max) -> void

    def inspect: () -> untyped
  end

  class WasmData
    attr_accessor memory_index: Integer

    attr_accessor offset: Integer

    attr_accessor init: String

    # @rbs &blk: (WasmData) -> void
    # @rbs return: void
    def initialize: () { (WasmData) -> void } -> void
  end

  class Block
    VOID: nil

    attr_accessor block_types: nil | Array[Integer]

    # @rbs return: Block
    def self.void: () -> Block

    # @rbs block_types: nil|Array[Integer]
    # @rbs return: void
    def initialize: (?nil | Array[Integer] block_types) -> void

    # @rbs return: bool
    def void?: () -> bool

    # @rbs return: Integer
    def result_size: () -> Integer
  end

  class Exports
    attr_accessor mappings: Hash[String, [ Integer, WasmFunction | ExternalFunction ]]

    # @rbs export_section: ExportSection
    # @rbs store: Store
    # @rbs return: void
    def initialize: (ExportSection export_section, Store store) -> void

    # @rbs name: String
    # @rbs return: [Integer, WasmFunction|ExternalFunction]
    def []: (String name) -> [ Integer, WasmFunction | ExternalFunction ]
  end

  # TODO: common interface btw. WasmFunction and ExternalFunction?
  class WasmFunction
    attr_accessor callsig: Array[Symbol]

    attr_accessor retsig: Array[Symbol]

    attr_accessor code_body: CodeSection::CodeBody

    # @rbs callsig: Array[Symbol]
    # @rbs retsig: Array[Symbol]
    # @rbs code_body: CodeSection::CodeBody
    # @rbs return: void
    def initialize: (Array[Symbol] callsig, Array[Symbol] retsig, CodeSection::CodeBody code_body) -> void

    # @rbs return: Array[Op]
    def body: () -> Array[Op]

    # @rbs return: Array[Symbol]
    def locals_type: () -> Array[Symbol]

    # @rbs return: Array[Integer]
    def locals_count: () -> Array[Integer]
  end

  class ExternalFunction
    attr_accessor callsig: Array[Symbol]

    attr_accessor retsig: Array[Symbol]

    attr_accessor callable: Proc

    # @rbs callsig: Array[Symbol]
    # @rbs retsig: Array[Symbol]
    # @rbs callable: Proc
    # @rbs return: void
    def initialize: (Array[Symbol] callsig, Array[Symbol] retsig, Proc callable) -> void
  end

  class GenericError < StandardError
  end

  class LoadError < StandardError
  end

  class ArgumentError < StandardError
  end

  class EvalError < StandardError
  end

  # @rbs path: String|nil
  # @rbs buffer: File|StringIO|nil
  # @rbs **options: Hash[Symbol, Object]
  # @rbs return: Instance
  def self.new: (?path: String | nil, ?buffer: File | StringIO | nil, **Hash[Symbol, Object] options) -> Instance
end
