# Generated from lib/wardite/value.rb with RBS::Inline

module Wardite
  module ValueHelper
    # @rbs value: Integer
    # @rbs return: I32
    def I32: (Integer value) -> I32

    # @rbs value: Integer
    # @rbs return: I64
    def I64: (Integer value) -> I64

    # @rbs value: Float
    # @rbs return: F32
    def F32: (Float value) -> F32

    # @rbs value: Float
    # @rbs return: F64
    def F64: (Float value) -> F64

    private

    # @rbs value: Integer
    # @rbs return: Integer
    def as_u32: (Integer value) -> Integer

    # @rbs value: Integer
    # @rbs return: Integer
    def as_u64: (Integer value) -> Integer
  end

  extend ValueHelper

  class I32
    include ValueHelper

    I32_MAX: untyped

    # value should be stored as unsigned Integer, even in I32/I64
    # when we want to access signed value, it'd be done via #value_s
    attr_accessor value: Integer

    # @rbs str: String
    # @rbs size: Integer|nil
    # @rbs signed: bool
    # @rbs return: I32
    def self.from_bytes: (String str, ?size: Integer | nil, ?signed: bool) -> I32

    # @rbs return: Integer
    def memsize: () -> Integer

    # returns a value interpreted as signed integer
    # @rbs return: Integer
    def value_s: () -> Integer

    # TODO: eliminate use of pack, to support mruby - in this file!
    # @rbs size: Integer|nil
    # @rbs return: String
    def packed: (?Integer | nil size) -> String

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def wrap: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def extend_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def extend_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def trunc_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def trunc_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def convert_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def convert_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def demote: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def promote: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def reinterpret: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # I32#inspect shows signed value for convinience
    def inspect: () -> untyped
  end

  class I64
    include ValueHelper

    I64_MAX: untyped

    attr_accessor value: Integer

    # @rbs str: String
    # @rbs size: Integer|nil
    # @rbs signed: bool
    # @rbs return: I64
    def self.from_bytes: (String str, ?size: Integer | nil, ?signed: bool) -> I64

    # @rbs return: Integer
    def memsize: () -> Integer

    # returns a value interpreted as signed integer
    # @rbs return: Integer
    def value_s: () -> Integer

    # @rbs size: Integer|nil
    # @rbs return: String
    def packed: (?Integer | nil size) -> String

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def wrap: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def extend_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def extend_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def trunc_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def trunc_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def convert_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def convert_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def demote: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def promote: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def reinterpret: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # I64#inspect shows signed value
    def inspect: () -> untyped
  end

  class F32
    include ValueHelper

    attr_accessor value: Float

    # @rbs str: String
    # @rbs return: F32
    def self.from_bytes: (String str) -> F32

    # @rbs return: Integer
    def memsize: () -> Integer

    # @rbs return: :positive|:negative
    def sign: () -> (:positive | :negative)

    # @rbs size: Integer|nil
    # @rbs return: String
    def packed: (?Integer | nil size) -> String

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def wrap: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def extend_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def extend_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @todo need more testcase...
    # @see https://webassembly.github.io/spec/core/exec/numerics.html#xref-exec-numerics-op-trunc-s-mathrm-trunc-mathsf-s-m-n-z
    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def trunc_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @see https://webassembly.github.io/spec/core/exec/numerics.html#xref-exec-numerics-op-trunc-u-mathrm-trunc-mathsf-u-m-n-z
    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def trunc_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def convert_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def convert_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def demote: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def promote: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def reinterpret: (to: Symbol) -> (I32 | I64 | F32 | F64)

    def inspect: () -> untyped
  end

  class F64
    include ValueHelper

    attr_accessor value: Float

    # @rbs str: String
    # @rbs return: F64
    def self.from_bytes: (String str) -> F64

    # @rbs return: Integer
    def memsize: () -> Integer

    # @rbs return: :positive|:negative
    def sign: () -> (:positive | :negative)

    # @rbs size: Integer|nil
    # @rbs return: String
    def packed: (?Integer | nil size) -> String

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def wrap: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def extend_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def extend_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @see the same as F32
    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def trunc_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @see the same as F32
    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def trunc_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def convert_s: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def convert_u: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @todo no loss of digits...
    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def demote: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def promote: (to: Symbol) -> (I32 | I64 | F32 | F64)

    # @rbs to: Symbol
    # @rbs return: I32|I64|F32|F64
    def reinterpret: (to: Symbol) -> (I32 | I64 | F32 | F64)

    def inspect: () -> untyped
  end
end
